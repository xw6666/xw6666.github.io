<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>当内存满的时，操作系统会做什么？</title>
    <link href="/2023/03/09/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6VS%E5%90%8E%E5%8F%B0%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/03/09/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6VS%E5%90%8E%E5%8F%B0%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>当应用程序通过malloc申请内存时，实际上申请的是虚拟内存，当CPU去访问具体的虚拟内存时，如果虚拟内存没有被映射成物理内存，此时CPU会产生<code>缺页中断</code>，然后应用程序会从用户态转换到内核态，并调用缺页终端处理函数，缺页中断处理函数会查看是否有未被使用的物理内存，如果有，将直接映射到页表，如果没有，则进行内存回收机制。</p><h1 id="后台内存回收（kswapd）"><a href="#后台内存回收（kswapd）" class="headerlink" title="后台内存回收（kswapd）"></a>后台内存回收（kswapd）</h1><p>后台内存回收是指在物理内存紧张的情况下，系统会启动内存回收机制来释放已分配但未使用的内存空间，以满足系统或进程的内存需求。后台内存回收主要由一个内核线程 <code>kswapd</code> 负责，它会定期扫描内存中的页面列表，并将不活跃的页面换出到交换空间中，以释放内存空间。</p><p>后台内存回收的过程是<code>异步</code>的，即 kswapd 内核线程会在后台执行内存回收操作，不会阻塞正在执行的进程。当系统内存使用率达到一定的阈值时，kswapd 线程会被唤醒，开始执行内存回收操作。kswapd 线程会首先尝试回收已经换出到交换空间中的页面，然后再回收未使用的内存页。</p><p>后台内存回收的速度取决于系统的内存压力和 kswapd 线程的优先级，系统会根据内存使用情况动态调整 kswapd 线程的优先级和内存回收策略，以保证系统的可用内存达到一定的水平。当系统内存使用率下降时，kswapd 线程会自动减少内存回收操作，直到内存使用率下降到一定的水平。</p><p>需要注意的是，后台内存回收虽然不会阻塞进程的执行，但会占用一定的系统资源，可能会对系统的性能产生一定的影响。因此，在设计和编写应用程序时，应该尽可能地减少内存使用，避免内存泄漏和内存过度申请，以提高系统的可靠性和性能。同时，系统管理员也应该及时调整系统参数，增加系统内存容量，以避免出现内存紧张的情况。</p><h1 id="直接内存回收"><a href="#直接内存回收" class="headerlink" title="直接内存回收"></a>直接内存回收</h1><p>直接内存回收是指当系统中可用内存不足以满足进程所需内存时，系统会启动内存回收机制来释放已分配但未使用的内存空间，以满足进程的内存需求。在直接内存回收期间，系统会直接回收已分配但未使用的内存页，以及通过页面换入机制换出的内存页，以获取更多的空闲内存。</p><p>直接内存回收的过程是<code>同步</code>的，即当系统开始回收内存时，会<code>阻塞</code>进程的执行，直到回收完成。这是因为直接内存回收需要遍历整个进程地址空间，找到未使用的内存页，并将这些内存页释放回内存池中，这个过程需要较长时间，会导致进程的执行暂停，直到内存回收完成。</p><p>在直接内存回收期间，系统会按照一定的策略来选择需要回收的内存页。例如，系统会优先回收长时间未使用的内存页，或者已被换出的内存页，以尽可能地减少对进程的影响。</p><p>值得注意的是，直接内存回收只是系统内存管理的一种应急措施，应该尽量避免其发生。因此，在编写应用程序时，应该尽可能地避免内存泄漏或内存过度申请，以免造成系统性能下降或应用程序崩溃等问题。同时，系统管理员也应该及时调整系统参数，增加系统内存容量，以提高系统的可靠性和性能。</p><hr><p>当如上方式回收内存还是无法满足使用时，内核将会触发OOM。</p><h1 id="OOM（Out-of-Memory）"><a href="#OOM（Out-of-Memory）" class="headerlink" title="OOM（Out of Memory）"></a>OOM（Out of Memory）</h1><p>OOM Killer机制会根据算法找到一个物理内存占用高的内存，然后将其杀死，如果还不够则继续杀，其实就是大家手机上的杀后台策略。</p>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址块划分问题</title>
    <link href="/2023/02/15/%E5%9C%B0%E5%9D%80%E5%9D%97%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/15/%E5%9C%B0%E5%9D%80%E5%9D%97%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天复习的时候看到这样一个问题：</p><p><img src="/images/%E5%9C%B0%E5%9D%80%E5%9D%97%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/1.jpg"></p><p>其实本质上考察的就是网段划分，首先先介绍一下CIDR划分方案：</p><ul><li><p> 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号;</p></li><li><p>子网掩码也是一个32位的正整数. 通常用一串 “0” 来结尾;</p></li><li><p>将IP地址和子网掩码进行 “按位与” 操作, 得到的结果就是网络号;</p></li><li><p>网络号和主机号的划分与这个IP地址是A类、B类还是C类无关;</p></li></ul><p>举一个例子：</p><p>假设有一个IP地址为<code>124.223.78.3</code>，子网掩码为<code>225.225.225.0</code>，那么将IP地址的32位二进制数和子网掩码32位二进制数按位与得到网络号：124.223.78.0，所以此时的子网范围就为<code>124.223.78.0~124.223.78.255</code>一共256个IP地址。</p><p>重点就在于这个256个IP地址是怎么来的，由于子网掩码最后0有8位，故该网段内一共可以容纳2^8 = 256个地址，所以我们可以得出一个结论，掩码后面有<code>x</code>个连续0，网段就能容纳<code>2^x</code>个IP地址。</p><p><strong>特殊的IP地址</strong></p><ul><li>将IP地址中的主机地址全部设为0, 就成为了网络号, 代表这个局域网</li><li>将IP地址中的主机地址全部设为1, 就成为了广播地址, 用于给同一个链路中相互连接的所有主机发送数据包;</li><li>127.*的IP地址用于本机环回(loop back)测试,通常是127.0.0.1</li></ul><p>回到问题中：当我们需要在一个地址块中能塞下150个地址和一个路由器地址，由于<code>2 ^ 7 - 2 &lt; 150 + 1 &lt; 2 ^ 8 - 2</code>所以需要子网掩码后8位为0<code>(减2是因为要留有网络号和广播地址)</code>，题目中告诉我们网络前缀位为23，也就是掩码有23个1，所以我们此时将掩码24位到32位设0即可，此时这个地址块给LAN3分配：</p><p>LAN3：30.138.118.0/24</p><p>同理：从要分配数多的地址块到少的地址块分析，LAN2主机数91，由于<code>2 ^ 6 - 2 &lt; 91 + 1 &lt; 2 ^ 7 - 2</code>，所以网络前缀号为32 - 7 = 25，之前24位为0时的网段分配给了LAN3，所以将24为置1，25位置0分配给LAN2</p><p>LAN2：30.138.119.0/25</p><p>之后LAN5和LAN1 LAN4一样这样分析即可。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>挑战leetcode hot 100（一）</title>
    <link href="/2023/01/23/%E6%8C%91%E6%88%98leetcode-hot-100%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/01/23/%E6%8C%91%E6%88%98leetcode-hot-100%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="本篇文章记录leetcode-hot-100中的1到10题的求解过程"><a href="#本篇文章记录leetcode-hot-100中的1到10题的求解过程" class="headerlink" title="本篇文章记录leetcode hot 100中的1到10题的求解过程"></a>本篇文章记录leetcode hot 100中的1到10题的求解过程</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p><img src="/images/leetcode1/1.png"></p><p>非常简单的一道题，将题目转换成<code>x + nums[i] == target</code>后得到<code>x == target - nums[i]</code>即可哈希。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(nums[i])) <span class="keyword">return</span> &#123;mp[nums[i]], i&#125;;</span><br><span class="line">            </span><br><span class="line">            mp[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><p><img src="/images/leetcode1/2.png"></p><p>类似归并排序，两边一路归并的加过去就好了，最后处理长的那一条链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> ListNode Node;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        Node* cur1 = l1;</span><br><span class="line">        Node* cur2 = l2;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        Node* head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp; cur2) &#123;</span><br><span class="line">            t += cur1-&gt;val + cur2-&gt;val;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(t % <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1) &#123;</span><br><span class="line">            t += cur1-&gt;val;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(t % <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2) &#123;</span><br><span class="line">            t += cur2-&gt;val;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(t % <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(t) &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(t % <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            cur = newNode;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p><img src="/images/leetcode1/3.png"></p><p>双指针扫一遍即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> h[<span class="number">130</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        h[s[l]]++;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[s[r]]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; h[s[r]]) &#123;</span><br><span class="line">                    h[s[l]]--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h[s[r]]++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随便一刷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用GitHub搭建一个个人博客</title>
    <link href="/2023/01/05/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/05/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>本文通过使用Hexo博客框架搭建静态博客，Hexo博客搭建简单，可以直接使用MarkDown直接写文章，然后Hexo将文章编译成静态文件就直接发布了，所以文章内容没有存放在数据库内。</p><h1 id="1-准备条件"><a href="#1-准备条件" class="headerlink" title="1.准备条件"></a>1.准备条件</h1><ul><li><p>GitHub账号</p></li><li><p>域名（非必须）</p></li></ul><h1 id="2-新建GitHub仓库"><a href="#2-新建GitHub仓库" class="headerlink" title="2.新建GitHub仓库"></a>2.新建GitHub仓库</h1><p>首先在GitHub任何页面右上角，使用+下拉菜单选择New repository。</p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/1.png"></p><p>这里的仓库名称设置为 <code>username.github.io</code>，一定是你的用户名+github.io，例如我的用户名是xw6666，所以我建立的仓库名为<code>xw6666.github.io</code></p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/2.png"></p><h1 id="3-为仓库设置SSH—key"><a href="#3-为仓库设置SSH—key" class="headerlink" title="3.为仓库设置SSH—key"></a>3.为仓库设置SSH—key</h1><h2 id="3-1创建密钥对"><a href="#3-1创建密钥对" class="headerlink" title="3.1创建密钥对"></a>3.1创建密钥对</h2><p>在git bash中输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>其中邮箱地址是你的github邮箱</p><p>然后连续三次回车，最终会生产文件在用户目录下，打开用户目录中的.ssh文件夹找到id_rsa.pub文件，如下图所示</p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/3.png"></p><p>使用记事本打开id_rsa.pub并复制其中的所有内容</p><p>之后打开你的GitHub主页点击右上角头像-&gt;Settings-&gt;SSH and GPG keys</p><p>选择<code>New SSH key</code> </p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/4.png"></p><p>将复制内容粘贴此处，Title随便写，之后点击<code>Add SSH key</code></p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/5.png"></p><h2 id="3-2测试是否添加成功"><a href="#3-2测试是否添加成功" class="headerlink" title="3.2测试是否添加成功"></a>3.2测试是否添加成功</h2><p>输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果看到以下类似内容，则测试成功。</p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/6.png"></p><h2 id="3-3配置git信息"><a href="#3-3配置git信息" class="headerlink" title="3.3配置git信息"></a>3.3配置git信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email  &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>此处一定要填写你的GitHub用户名和GitHub绑定的邮箱。</p><h1 id="4-环境安装"><a href="#4-环境安装" class="headerlink" title="4.环境安装"></a>4.环境安装</h1><h2 id="4-1安装node-js"><a href="#4-1安装node-js" class="headerlink" title="4.1安装node.js"></a>4.1安装node.js</h2><p>在官网选择对应的系统安装则可，记得安装时要勾选写进环境变量中<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>安装完成后，首先进行重启！！！</p><p>重启完后在命令提示符中输入以下命令查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>如果显示了版本号则成功，进入下一步</p><h2 id="4-2安装Hexo"><a href="#4-2安装Hexo" class="headerlink" title="4.2安装Hexo"></a>4.2安装Hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完后输入hexo，如出现提示符则安装成功，无命令则安装失败。</p><h1 id="5-初始化项目"><a href="#5-初始化项目" class="headerlink" title="5.初始化项目"></a>5.初始化项目</h1><h2 id="5-1创建项目"><a href="#5-1创建项目" class="headerlink" title="5.1创建项目"></a>5.1创建项目</h2><p>使用hexo命令行在你想要的目录下创建项目目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#123;name&#125;</span><br></pre></td></tr></table></figure><p>这里的name就是项目名字，和你的github用户名相同即可，比如我的就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init xw6666</span><br></pre></td></tr></table></figure><p>不出意外你所在目录下会出现一个新的文件夹，这个文件夹就是项目文件</p><h2 id="5-2编译生成HTML代码"><a href="#5-2编译生成HTML代码" class="headerlink" title="5.2编译生成HTML代码"></a>5.2编译生成HTML代码</h2><p>首先进入刚才生成的文件夹内，在cmd下或者git bash下输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h2 id="5-3本地运行项目"><a href="#5-3本地运行项目" class="headerlink" title="5.3本地运行项目"></a>5.3本地运行项目</h2><p>输入以下命令本地运行项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>之后项目会默认跑在<a href="http://localhost:4000/">http://localhost:4000/</a>下，打开浏览器进入会看到你的博客例如：</p><p><img src="/images/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/7.png"></p><h1 id="6-部署项目"><a href="#6-部署项目" class="headerlink" title="6.部署项目"></a>6.部署项目</h1><p>部署项目以后，别人就能访问到你的网站了，hexo给了我们命令让我们可以直接无脑部署。</p><h2 id="6-1设置部署地址"><a href="#6-1设置部署地址" class="headerlink" title="6.1设置部署地址"></a>6.1设置部署地址</h2><p>打开项目根目录下的<code>_config.yml</code>文件，拉到最底下可以看到Deployment，把新建好的复制过来，指定分支为mastero保存退出即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xw6666/xw6666.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="6-2安装git部署插件"><a href="#6-2安装git部署插件" class="headerlink" title="6.2安装git部署插件"></a>6.2安装git部署插件</h2><p>需要额外在项目目录下安装一个部署插件，如果不安装会报错，安装插件的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="6-3部署项目"><a href="#6-3部署项目" class="headerlink" title="6.3部署项目"></a>6.3部署项目</h2><p>执行如下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -d</span><br></pre></td></tr></table></figure><p>如果此时出现连接不上github而导致失败的情况，可以参考以下两篇博客：</p><p><a href="https://blog.csdn.net/Hodors/article/details/103226958">https://blog.csdn.net/Hodors/article/details/103226958</a></p><p><a href="https://blog.csdn.net/weixin_40908748/article/details/122367878">https://blog.csdn.net/weixin_40908748/article/details/122367878</a></p><h2 id="6-4访问测试"><a href="#6-4访问测试" class="headerlink" title="6.4访问测试"></a>6.4访问测试</h2><p>成功后，这时候我们访问一下 GitHub Repository 同名的链接，比如我的<code>xw6666</code>博客的 Repository 名称取的是<code>xw6666.github.io</code>，那我就访问 <a href="http://xw6666.github.io/">http://xw6666.github.io</a>，这时候我们就可以看到跟本地一模一样的博客内容了，如果看不到不要着急，github有延迟，等几分钟就行了。</p><h2 id="6-5备份源码"><a href="#6-5备份源码" class="headerlink" title="6.5备份源码"></a>6.5备份源码</h2><p>因为是静态博客，所以我写的文章都在本地，那我换了电脑之后就没了，所以需要备份，备份很简单，新建一个其他分支，然后全push上去就行了，例如我创建了一个source分支保存源码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init    //初始化项目</span><br><span class="line">git checkout -b source    //创建并切换到source分支</span><br><span class="line">git add -A    //添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;init blog&quot;    //提交并注释</span><br><span class="line">git remote add origin git@github.com:xw6666/xw6666.github.io.git    //添加到远程仓库</span><br><span class="line">git push origin source    //将代码提交到远程的source分支</span><br></pre></td></tr></table></figure><h2 id="6-6配置主题"><a href="#6-6配置主题" class="headerlink" title="6.6配置主题"></a>6.6配置主题</h2><p>默认的主题肯定是不好看的，可以去网上找一套主题，之后把主题的文件夹放在项目下的<code>themes</code>文件夹中，并在项目根目录的<code>_config.yml</code>中找到<code>theme: </code>，填入你的主题文件夹名字即可。</p><h1 id="7-域名解析"><a href="#7-域名解析" class="headerlink" title="7.域名解析"></a>7.域名解析</h1><p>具体可以参考这篇文章，这里不再赘述</p><p><a href="https://blog.csdn.net/lijing742180/article/details/85549978">https://blog.csdn.net/lijing742180/article/details/85549978</a></p><h1 id="8-写文章"><a href="#8-写文章" class="headerlink" title="8.写文章"></a>8.写文章</h1><p>博客搭建好了，可以在本地写文章上传。</p><h2 id="8-1生成文章"><a href="#8-1生成文章" class="headerlink" title="8.1生成文章"></a>8.1生成文章</h2><p>在项目根目录中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;你要写的文章标题&quot;</span><br></pre></td></tr></table></figure><p>之后hexo会自动在<code>source/_posts</code>下生成一个markdown文档，在里面写就行了。</p><h2 id="8-2上传文章"><a href="#8-2上传文章" class="headerlink" title="8.2上传文章"></a>8.2上传文章</h2><p>在根目录输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   //清除一些缓存</span><br><span class="line">hexo g -d    //编译文件并上传至云端</span><br></pre></td></tr></table></figure><p>成功之后在你的网站等几分钟就更新了。</p><h2 id="8-3备份文章"><a href="#8-3备份文章" class="headerlink" title="8.3备份文章"></a>8.3备份文章</h2><p>养成好习惯，写完一篇文章上传以后立马备份：</p><p>首先先切换以下分支，我的备份分支叫<code>source</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout source</span><br></pre></td></tr></table></figure><p>之后就是git三板斧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .  //将当前目录下的所有内容加入</span><br><span class="line">git commit -m &quot;注释&quot;  //提交并注释</span><br><span class="line">git push origin source   //推送到远端分支</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于阻塞队列的生产消费者模型实现</title>
    <link href="/2023/01/03/%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/03/%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-模型介绍"><a href="#1-模型介绍" class="headerlink" title="1.模型介绍"></a>1.模型介绍</h1><p>生产者消费者模型就是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。</p><h1 id="2-模型优点"><a href="#2-模型优点" class="headerlink" title="2.模型优点"></a>2.模型优点</h1><ul><li>解耦</li><li>支持并发</li><li>支持忙闲不均</li></ul><h1 id="3-基于BlockingQueue的生产消费者模型"><a href="#3-基于BlockingQueue的生产消费者模型" class="headerlink" title="3.基于BlockingQueue的生产消费者模型"></a>3.基于BlockingQueue的生产消费者模型</h1><p>在多线程编程中<code>阻塞队列(Blocking Queue)</code>是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)</p><p><img src="/images/%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/1.png"></p><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h1><h2 id="4-1Blocking-Queue-hpp主体代码"><a href="#4-1Blocking-Queue-hpp主体代码" class="headerlink" title="4.1Blocking Queue.hpp主体代码"></a>4.1Blocking Queue.hpp主体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns_block_queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> g_cap = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BlockQueue</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::queue&lt;T&gt; bq_;</span><br><span class="line">        <span class="type">int</span> cap_;</span><br><span class="line">        <span class="type">pthread_mutex_t</span> mtx_;</span><br><span class="line">        <span class="type">pthread_cond_t</span> full_;  <span class="comment">// full表示是否有产品，消费者等</span></span><br><span class="line">        <span class="type">pthread_cond_t</span> empty_; <span class="comment">// empty表示是否有空位，生产者等</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;mtx_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">UnLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mtx_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">WaitEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 等空位</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;empty_, &amp;mtx_); <span class="comment">// 第二个参数是挂起时交出的锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">WaitFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 等产品</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;full_, &amp;mtx_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SignalConsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 通知消费者有产品</span></span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;full_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SignalProducter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 通知生产者已经有空位了</span></span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;empty_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cap_ == bq_.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bq_.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BlockQueue</span>(<span class="type">int</span> cap = g_cap) : <span class="built_in">cap_</span>(cap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_init</span>(&amp;mtx_, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;full_, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="built_in">pthread_cond_init</span>(&amp;empty_, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">BlockQueue</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;mtx_);</span><br><span class="line">            <span class="built_in">pthread_cond_destroy</span>(&amp;full_);</span><br><span class="line">            <span class="built_in">pthread_cond_destroy</span>(&amp;empty_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T &amp;in)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">Lock</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">IsFull</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">WaitEmpty</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            bq_.<span class="built_in">push</span>(in);</span><br><span class="line">            <span class="built_in">UnLock</span>();</span><br><span class="line">            <span class="built_in">SignalConsumer</span>();   <span class="comment">//通知消费者</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(T *out)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">Lock</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">IsEmpty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">WaitFull</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            *out = bq_.<span class="built_in">front</span>();</span><br><span class="line">            bq_.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">UnLock</span>();</span><br><span class="line">            <span class="built_in">SignalProducter</span>();  <span class="comment">//通知生产者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2模拟任务派发的Task-hpp任务类代码"><a href="#4-2模拟任务派发的Task-hpp任务类代码" class="headerlink" title="4.2模拟任务派发的Task.hpp任务类代码"></a>4.2模拟任务派发的Task.hpp任务类代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns_task &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x_;</span><br><span class="line">        <span class="type">int</span> y_;</span><br><span class="line">        <span class="type">char</span> op_;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Task</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Task</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> op):<span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y), <span class="built_in">op_</span>(op)&#123;&#125;;</span><br><span class="line">        ~<span class="built_in">Task</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (op_)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                ans = x_ + y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                ans = x_ - y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                ans = x_ * y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                ans = x_ / y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">                ans = x_ % y_;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Bug????&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前任务正在被&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot;线程处理：&quot;</span> &lt;&lt; x_ &lt;&lt; op_ &lt;&lt; y_ &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Run</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-3模拟生产消费者运行代码"><a href="#4-3模拟生产消费者运行代码" class="headerlink" title="4.3模拟生产消费者运行代码"></a>4.3模拟生产消费者运行代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BlockQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns_block_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns_task;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq = (BlockQueue&lt;Task&gt; *)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        Task t;</span><br><span class="line">        bq-&gt;<span class="built_in">Pop</span>(&amp;t);</span><br><span class="line">        <span class="built_in">t</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producter</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq = (BlockQueue&lt;Task&gt; *)arg;</span><br><span class="line">    std::string ops = <span class="string">&quot;+-*/%&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> op = ops[<span class="built_in">rand</span>() % <span class="number">5</span>];</span><br><span class="line">        <span class="function">Task <span class="title">t</span><span class="params">(x, y, op)</span></span>;</span><br><span class="line">        bq-&gt;<span class="built_in">Push</span>(t);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;生产者&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot;生产了&quot;</span> &lt;&lt; x &lt;&lt; op &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    BlockQueue&lt;Task&gt; *bq = <span class="keyword">new</span> <span class="built_in">BlockQueue</span>&lt;Task&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> c[<span class="number">3</span>], p[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(p + i, <span class="literal">nullptr</span>, producter, (<span class="type">void</span> *)bq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(c + i, <span class="literal">nullptr</span>, consumer, (<span class="type">void</span> *)bq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(p[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(c[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4makefile"><a href="#4-4makefile" class="headerlink" title="4.4makefile"></a>4.4makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">CpTest:CpTest.cc</span></span><br><span class="line">g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11 -lpthread</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f CpTest</span><br></pre></td></tr></table></figure><h1 id="5运行效果"><a href="#5运行效果" class="headerlink" title="5运行效果"></a>5运行效果</h1><p><img src="/images/%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态库与动态库的制作与使用</title>
    <link href="/2022/11/14/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/14/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="静态库制作与使用"><a href="#静态库制作与使用" class="headerlink" title="静态库制作与使用"></a>静态库制作与使用</h1><p>静态库以.a后缀结尾，制作方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libxxx.a:xx.o xx.o xx.o</span><br><span class="line">ar -rc $@ $^       //直接打包</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">gcc -c $&lt;                          </span><br></pre></td></tr></table></figure><p>当需要使用静态库时，如下编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o $@ $^ -l头文件路径 -L库路径 -l库名   </span><br></pre></td></tr></table></figure><h1 id="动态库制作与使用"><a href="#动态库制作与使用" class="headerlink" title="动态库制作与使用"></a>动态库制作与使用</h1><p>静态库以.so后缀结尾，制作方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libxxx.so:xx.o xx.o</span><br><span class="line">gcc -shared -o $@ $^ </span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">gcc -fPIC -c $&lt;   //-fPIC全部生成绝对地址，因为动态库用的时候才调用</span><br></pre></td></tr></table></figure><p>当需要使用动态库时，有如下方法：</p><ul><li><p>首先先编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o $@ $ -I+头文件路径 -L+库路径 -l+库名</span><br></pre></td></tr></table></figure></li><li><p>需要更改LD_LIBRARY_PATH环境变量路径</p></li><li><p>或者将.so文件拷贝到系统共享库目录下，一般是/usr/lib</p></li><li><p>ldconfig 配置/etc/ld.so.conf.d/, ldconfig更新</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体空间大小计算方法</title>
    <link href="/2022/03/31/%E7%BB%93%E6%9E%84%E4%BD%93%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/31/%E7%BB%93%E6%9E%84%E4%BD%93%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="共用体空间大小计算"><a href="#共用体空间大小计算" class="headerlink" title="共用体空间大小计算"></a>共用体空间大小计算</h2><p>每个成员变量都从同一个地址开始存储，共用一块空间<br>假设num从0号地址开始存放，int四个字节，即0,1,2,3四个地址存放的是int<br>name是5个连续的char变量，也从0开始存放占用0，1，2，3，4五个地址空间<br>s占用0地址空间<br>共有体的大小（单位字节）一定是最大成员变量类型大小的整数倍<br>在以下结构体中，占空间最大的类型是int(char[5]本质是5个char)，所以结构体大小一定是4的整数倍<br>即4，8，12，16..由于4个字节不够装下char name[5]，所以这个结构体大小是8字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">stu1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据上述分析，这个结构体字节大小只能是8,16,24...所以结构体大小是16字节</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">stu3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结构体对齐规则"><a href="#结构体对齐规则" class="headerlink" title="结构体对齐规则"></a>结构体对齐规则</h2><ol><li>第一个成员在与结构体变量偏移量为0的地址处。</li><li>其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。</li><li>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</li><li>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的总大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</li></ol><p>对齐数 = min(编译器默认对齐数，该成员类型大小)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来具体分析一下 上述结构体：</p><p>首先假设num从0地址处开始存放，所以占用0,1,2,3四个地址(第一个成员在与结构体变量偏移量为0的地址处)，然后name本质上是连续的char类型，char的对齐数是 min(8, sizeof(char)) = 1，所以地址4是可以放char的，因为4是1的倍数，于是4到8这5个地址存储 name[5]，之后s的对齐数还是1，所以9号地址放s，这时候我们一共使用了10个地址(0到9)，根据结构体总大小为最大对齐数的整数倍，这里的最大对齐数是int的对齐数是4,所以一定要是4的整数倍，所以10字节不是我们的答案，12才是。</p><p>再来一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name假设放0地址数，num的对齐数是min(8,sizeof(int)) = 4,所以num从4号开始放，占用4,5,6,7</p><p>最后char占用8号地址，一共使用9个字节空间(0到8),不是4的整数倍，所以补到12个字节空间，结构体总大小为12字节。</p><h2 id="自己设置对齐数"><a href="#自己设置对齐数" class="headerlink" title="自己设置对齐数"></a>自己设置对齐数</h2><p>通过#pragma pack()宏，可以实现自己设置对齐数</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> pack(1)   <span class="comment">//设置对齐数为1</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stu2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候所有的成员大小都是1的倍数，所以直接顺序存放，name假设放0地址处，num就放1，2，3，4，s放5，一共6个字节，是对齐数1的倍数，不用额外空间。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传送</title>
    <link href="/2022/03/31/%E4%BC%A0%E9%80%81/"/>
    <url>/2022/03/31/%E4%BC%A0%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h1><p><img src="/images/%E4%BC%A0%E9%80%81/%E9%A2%98%E7%9B%AE.png"></p><p>思路：</p><p>直接枚举所有情况</p><ol><li>直接从a到b的距离</li><li>从a走x传送门到y，从y到b的距离</li><li>从a走y传送门到x，从x到b的距离<br>这三种情况选一个最短的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, x, y;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">abs</span>(a - b);    <span class="comment">//a直接到b</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a - y) + <span class="built_in">abs</span>(b - x));   <span class="comment">//a先到y，再从x到b</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(a - x) + <span class="built_in">abs</span>(b - y));   <span class="comment">//a先到x，再从y到b</span></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：晓伍</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/106879/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻挡广告牌II</title>
    <link href="/2022/03/30/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8CII/"/>
    <url>/2022/03/30/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8CII/</url>
    
    <content type="html"><![CDATA[<h1 id="阻挡广告牌II"><a href="#阻挡广告牌II" class="headerlink" title="阻挡广告牌II"></a>阻挡广告牌II</h1><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/%E9%A2%98%E7%9B%AE.png"></p><p>思路：直接找能够让覆盖面积减少的条件，不难发现只有以下五种：</p><ul><li><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/QQ%E5%9B%BE%E7%89%8720220330214941.png"></p></li><li><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/QQ%E6%88%AA%E5%9B%BE20220329232743.png"></p></li><li><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/QQ%E6%88%AA%E5%9B%BE20220330215114.png"></p></li><li><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/QQ%E6%88%AA%E5%9B%BE20220330215128.png"></p></li><li><p><img src="/images/%E9%98%BB%E6%8C%A1%E5%B9%BF%E5%91%8A%E7%89%8C2/QQ%E6%88%AA%E5%9B%BE20220330215151.png"></p></li></ul><p>所以分类讨论直接代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">abs</span>(x1 - x2) * <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x3,y3,x4,y4;</span><br><span class="line">    cin &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x3 &lt;= x1 &amp;&amp; x4 &gt;= x2 &amp;&amp; y3 &lt;= y1 &amp;&amp; y4 &gt;= y2) s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x1 &gt;= x3 &amp;&amp; x2 &lt;= x4 &amp;&amp; y1 &lt;= y4 &amp;&amp; y4 &lt;= y2 &amp;&amp; y3 &lt;= y1) s = <span class="built_in">abs</span>(y2 - y4) * <span class="built_in">abs</span>(x1 - x2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x1 &gt;= x3 &amp;&amp; x2 &lt;= x4 &amp;&amp; y1 &lt;= y3 &amp;&amp; y3 &lt;= y2 &amp;&amp; y4 &gt;= y2) s = <span class="built_in">abs</span>(y3 - y1) * <span class="built_in">abs</span>(x1 - x2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y1 &gt;= y3 &amp;&amp; y2 &lt;= y4 &amp;&amp; x1 &lt;= x4 &amp;&amp; x4 &lt;= x2 &amp;&amp; x1 &gt;= x3) s = <span class="built_in">abs</span>(x4 - x2) * <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y1 &gt;= y3 &amp;&amp; y2 &lt;= y4 &amp;&amp; x1 &lt;= x3 &amp;&amp; x3 &lt;= x2 &amp;&amp; x2 &lt;= x4) s = <span class="built_in">abs</span>(x3 - x1) * <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社交距离I</title>
    <link href="/2022/03/23/%E7%A4%BE%E4%BA%A4%E8%B7%9D%E7%A6%BBI/"/>
    <url>/2022/03/23/%E7%A4%BE%E4%BA%A4%E8%B7%9D%E7%A6%BBI/</url>
    
    <content type="html"><![CDATA[<h1 id="社交距离I"><a href="#社交距离I" class="headerlink" title="社交距离I"></a>社交距离I</h1><p><img src="/images/%E7%A4%BE%E4%BA%A4%E8%B7%9D%E7%A6%BB1/QQ%E6%88%AA%E5%9B%BE20220329232743.png"></p><p>思路：我们可以通过二分答案来判断此答案下是否能放下两头牛</p><p>具体看代码注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">char</span> s[N];    </span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍，如果当前位置是x，则x前面有牛的位置和x距离要大于等于mid，后面有牛的位置与x距离要大于等于mid就能放下一头牛</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, last = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span> &amp;&amp; i - last &gt;= mid &amp;&amp; ne[i] - i &gt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;    <span class="comment">//每放一头牛cnt++</span></span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//能放两头就是合格</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>) last = i;     <span class="comment">//不断更新上一头牛的坐标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ne,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ne));</span><br><span class="line">    <span class="type">int</span> d = n, last = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">1</span>)    <span class="comment">//如果有牛，检查一下能不能更新d，并记录这个牛的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="built_in">min</span>(d, i - last);</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ne[i]表示i处的下一个有牛的位置是ne[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i + <span class="number">1</span>] == <span class="number">1</span>) ne[i] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ne[i] = ne[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = d;    <span class="comment">//对最小距离1和现在距离d进行二分答案</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三角形</title>
    <link href="/2022/03/22/%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2022/03/22/%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h1><p><img src="/images/%E4%B8%89%E8%A7%92%E5%BD%A2/QQ%E6%88%AA%E5%9B%BE20220329232219.png"></p><p>思路：由于最大n就到100，三重循环暴力枚举三个点即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; a.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>;k &lt; a.<span class="built_in">size</span>();k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x1 = a[i].x, y1 = a[i].y;</span><br><span class="line">                <span class="type">int</span> x2 = a[j].x, y2 = a[j].y;</span><br><span class="line">                <span class="type">int</span> x3 = a[k].x, y3 = a[k].y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(x1 == x2 &amp;&amp; y1 == y3)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y2 - y1) * <span class="built_in">abs</span>(x1 - x3));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x1 == x3 &amp;&amp; y1 == y2)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y1 - y3) * <span class="built_in">abs</span>(x1 - x2));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x2 == x1 &amp;&amp; y2 == y3)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y2 - y1) * <span class="built_in">abs</span>(x3 - x2));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x2 == x3 &amp;&amp; y2 == y1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y2 - y3) * <span class="built_in">abs</span>(x2 - x1));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x3 == x1 &amp;&amp; y3 == y2)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y1 - y3) * <span class="built_in">abs</span>(x3 - x2));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(x3 == x2 &amp;&amp; y3 == y1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(y2 - y3) * <span class="built_in">abs</span>(x1 - x3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单词处理器</title>
    <link href="/2022/03/19/%E5%8D%95%E8%AF%8D%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/03/19/%E5%8D%95%E8%AF%8D%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="单词处理器"><a href="#单词处理器" class="headerlink" title="单词处理器"></a>单词处理器</h1><p>本题来自于[](<a href="https://www.acwing.com/problem/content/1444/">1442. 单词处理器 - AcWing题库</a>)</p><p><img src="/images/%E5%8D%95%E8%AF%8D%E5%A4%84%E7%90%86%E5%99%A8/%E5%8D%95%E8%AF%8D%E5%A4%84%E7%90%86%E5%99%A8.png"></p><p>思路：这道题是一道简单的模拟题，我们只需要维护一个当前行数的字符数cnt</p><ul><li>如果cnt加上下一个串的字符数会大于题目给的k，就另起一行打印字符串，并把cnt更新为这个串的字符数</li><li>如果cnt加上下一个串的字符数小于等于k，就直接在本行打印字符串，并把cnt加等于这个串的字符数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        cnt += s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cnt = s.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年赛题解</title>
    <link href="/2022/03/19/%E8%A1%8C%E7%9F%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/03/19/%E8%A1%8C%E7%9F%A5%E6%9D%AF%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/A.png"></p><p>思路：由于每个数字只会出现一次，我们可以先排序，之后每个数字的下标和值会相等，例如a[0] = 0,a[1] = 1，我们只需要遍历数组，找到第一个数组下标和值不等的地方，这个就是缺少的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);   <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找第一个数组下标和数字不同的地方</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] != i) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/B.png"></p><p>思路：由于只用64个位置，我们可以遍历64个格子并且维护一个变量ans = 0，每个格子假设是我们放马的格子，每次判断我们放的马的八个方向和本来已经在棋盘上的方向，如果合法ans++，最后输出的ans就是合法格子数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;;   <span class="comment">//马的八个方向分量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);  <span class="comment">//读入坐标</span></span><br><span class="line"><span class="type">int</span> a = op[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, b = op[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//将字符坐标转换成整形</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"><span class="type">int</span> c = op[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, d = op[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">8</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == c &amp;&amp; j == d) <span class="keyword">continue</span>;     <span class="comment">//如果这个位置是马在的位置直接跳过</span></span><br><span class="line"><span class="keyword">if</span>(i == a || j == b) <span class="keyword">continue</span>;     <span class="comment">//如果这个位置是车的所在的行或者列直接跳过</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//遍历棋盘上原来的马的八个方位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">8</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tx = c + dx[k];</span><br><span class="line"><span class="type">int</span> ty = d + dy[k];</span><br><span class="line"><span class="keyword">if</span>(tx &lt; <span class="number">1</span> || tx &gt; <span class="number">8</span> || ty &lt; <span class="number">1</span> || ty &gt; <span class="number">8</span>) <span class="keyword">continue</span>;   <span class="comment">//如果坐标越界直接跳过</span></span><br><span class="line"><span class="keyword">if</span>(tx == i &amp;&amp; ty == j) flag = <span class="literal">false</span>;                 <span class="comment">//如果棋盘上的马能踩到(i,j)的马，这个位置不能放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;  </span><br><span class="line"><span class="comment">//遍历我们要放的马的八个方向</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">8</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tx = i + dx[k];</span><br><span class="line"><span class="type">int</span> ty = j + dy[k];</span><br><span class="line"><span class="keyword">if</span>(tx &lt; <span class="number">1</span> || tx &gt; <span class="number">8</span> || ty &lt; <span class="number">1</span> || ty &gt; <span class="number">8</span>) <span class="keyword">continue</span>;     <span class="comment">//如果坐标越界直接跳过</span></span><br><span class="line"><span class="keyword">if</span>((a == tx &amp;&amp; b == ty))</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;                 <span class="comment">//如果这个方向能攻击到棋盘上原有的马，坐标不合法</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/C.png"></p><p>思路：维护两个变量：字符A的数量asize和字符A的数量bsize</p><ul><li>如果当前字符是A，asize++</li><li>如果当前字符是B，bsize++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>;    <span class="comment">//字符a的数量和字符b的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">&#x27;A&#x27;</span>) a++;</span><br><span class="line"><span class="keyword">else</span> b++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == b) cout &lt;&lt; <span class="string">&#x27;T&#x27;</span> &lt;&lt; endl;   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b) cout &lt;&lt; <span class="string">&#x27;A&#x27;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;B&#x27;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/D.png"></p><p>思路：数据量是1000，如果三重循环，我们要计算1e9级别的数据，这样肯定是会超时的，我们先排序，由于第三重循环要在[XY,2XY]中，且排序后数据单调，我们可以使用二分查找找到第一个大于等于XY的数的下标和最后一个小于2XY的数的下标，得到了下标之后，下标相减加1就是当前的合法三元组数量</p><p>时间复杂度分析，排序nlogn + 二重循环和两次二分2 * N^2logn为O(N^2 log n)，符合题目要求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> t1,<span class="type">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = l1,r = r1;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(alls[mid] &gt;= t1) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans1 = l;</span><br><span class="line">l = l1,r = r1;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(alls[mid] &lt;= t2) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans2 = l;</span><br><span class="line"><span class="keyword">if</span>(ans2 == ans1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(alls[ans1] &gt;= t1 &amp;&amp; alls[ans1] &lt;= t2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans2 &gt; ans1) <span class="keyword">return</span> ans2 - ans1 + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; alls.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; alls.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="built_in">check</span>(j + <span class="number">1</span>,alls.<span class="built_in">size</span>() - <span class="number">1</span>,alls[j] - alls[i] + alls[j], <span class="number">2</span> * (alls[j] - alls[i]) + alls[j]); <span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">if</span>(temp) ans += temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/E.png"></p><p>思路：通过dfs把两块区域的点记录下来，之后二重循环遍历所有两块区域中的点，算他们的曼哈顿距离-1，并得到最小的距离，时间复杂度度O(m*n)，具体看代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> map[N][N];</span><br><span class="line"><span class="type">bool</span> v[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; a,b;   <span class="comment">//a存放第一块区域的坐标，b存放第二块区域的坐标</span></span><br><span class="line"><span class="type">int</span> temp;    <span class="comment">//如果当前的temp == 0，代表都是第一块区域的坐标，把坐标往a存，如果temp == 1，把坐标往b存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">//上下左右四个坐标分量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[x][y] = <span class="number">1</span>;   <span class="comment">//标记当前点已经被访问过</span></span><br><span class="line"><span class="keyword">if</span>(map[x][y] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前的temp == 0，代表都是第一块区域的坐标，把坐标往a存，如果temp == 1，把坐标往b存</span></span><br><span class="line"><span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x1 = x + dx[i];</span><br><span class="line"><span class="type">int</span> y1 = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; n &amp;&amp; y1 &gt;= <span class="number">0</span> &amp;&amp; y1 &lt; m &amp;&amp; !v[x1][y1])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(x1,y1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, map[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="string">&#x27;X&#x27;</span>)   <span class="comment">//如果是&#x27;X&#x27;则是我们要dfs的地方</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i,j);</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1000</span>;   <span class="comment">//ans任取一个大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : b)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">abs</span>(i.first - j.first) + <span class="built_in">abs</span>(i.second - j.second) - <span class="number">1</span>);   <span class="comment">//求出最小的两个坐标之间的距离</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="F题"><a href="#F题" class="headerlink" title="F题"></a>F题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/F.png"></p><p>思路：此题为线性dp，我们需要考虑状态转移方程</p><ul><li>定义f[i]表示从0号车到i - 1号车之间，我们能偷到的最大金额为f[i]，所以答案为f[n - 1]</li><li>分类讨论f[i]<ol><li>如果我们不偷i号车，那么f[i] = f[i - 1]</li><li>如果我们偷i号车，那么f[i] = f[i - 2] + v[i]    (因为相邻的车偷不了，所以是f[i - 2]，v[i]表示下标为i号车的价值)</li></ol></li><li>由于我们要最大价值，所以f[i] = max(f[i - 1], f[i - 2] + v[i])</li><li>分析初始状态，如果只有一辆车，能偷到的最大金额就是这辆车的价值(一定偷)，所以f[0] = v[0]，如果只有两辆车，能偷到的最大金额就是两辆车中价值大的那一辆，所以f[1] = max(v[0], v[1])</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];    <span class="comment">//f[i]表示从0好车到i - 1号车之间，我们能偷到的最大金额为f[i]，所以答案为f[n - 1]</span></span><br><span class="line"><span class="type">int</span> a[N];    <span class="comment">//a[i]表示下标为i号的车价值为a[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">f[<span class="number">1</span>] = <span class="built_in">max</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; n;i++) f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>] + a[i]);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="G题"><a href="#G题" class="headerlink" title="G题"></a>G题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/G.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;95\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="H题"><a href="#H题" class="headerlink" title="H题"></a>H题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/H.png"></p><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p><p>如图所示：有三种情况，定义f[i]表示长为i米的放陷阱方法为f[i]种</p><p>不难得出f[i] = f[i - 1] + f[i - 2] + f[i - 2]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;    <span class="comment">//一米长的就1种</span></span><br><span class="line">f[<span class="number">2</span>] = <span class="number">3</span>;    <span class="comment">//二米长的就3种</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt;= <span class="number">30</span>;i++) f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span> * f[i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tt;</span><br><span class="line">cin &gt;&gt; tt;</span><br><span class="line"><span class="keyword">while</span>(tt--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; f[x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure><h1 id="I题"><a href="#I题" class="headerlink" title="I题"></a>I题</h1><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/I.png"></p><p><img src="/images/%E7%9F%A5%E8%A1%8C%E6%9D%AF/I%E9%A2%98%E8%A7%A3.png"></p><p>思路：如图所示:</p><ul><li><p>a和c点取小的，b和d点取大的，然后相减得到一条边的长度</p></li><li><p>e和g点取大的，f和h点取小的，然后相减得到另一条边的长度</p></li></ul><p>由于要正方形，所以两条边的长度取长的平方得到的面积就是答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2,x3,y3,x4,y4;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">min</span>(x1,x3),b = <span class="built_in">min</span>(y1,y3);</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">max</span>(x2,x4),d = <span class="built_in">max</span>(y2,y4);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="built_in">max</span>(<span class="built_in">abs</span>(a - c), <span class="built_in">abs</span>(b - d));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans * ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：晓伍</span></span><br><span class="line"><span class="comment">//链接：http://124.223.78.3/</span></span><br><span class="line"><span class="comment">//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奶牛体操</title>
    <link href="/2022/03/17/%E5%A5%B6%E7%89%9B%E4%BD%93%E6%93%8D/"/>
    <url>/2022/03/17/%E5%A5%B6%E7%89%9B%E4%BD%93%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="奶牛体操"><a href="#奶牛体操" class="headerlink" title="奶牛体操"></a>奶牛体操</h1><p>本题来自于[这里](<a href="https://www.acwing.com/problem/content/description/1461/">1459. 奶牛体操 - AcWing题库</a>)</p><p><img src="/images/%E5%A5%B6%E7%89%9B%E4%BD%93%E6%93%8D/QQ%E6%88%AA%E5%9B%BE20220317232959.png"></p><p>由于数据量比较小，所以直接考虑暴力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> k,n;</span><br><span class="line"><span class="type">int</span> s[N][N];    <span class="comment">//s[i][j]表示i号牛排名大于j号牛的情况出现了s[i][j]次</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[j];      <span class="comment">//读入一组牛排名</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = j + <span class="number">1</span>;l &lt; n;l++) s[a[j]][a[l]]++;   <span class="comment">//a[j]号牛的排名大于a[l]号牛，所以s[a[j]][a[l]]++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找答案</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当i和j是同一头牛直接跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j] &amp;&amp; s[j][i] == <span class="number">0</span>) ans++;  <span class="comment">//如果i牛有大于j牛的情况，但是j牛从来没有大于过i牛，就是一对一致的奶牛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛的学术圈1</title>
    <link href="/2022/03/16/%E7%89%9B%E7%9A%84%E5%AD%A6%E6%9C%AF%E5%9C%881/"/>
    <url>/2022/03/16/%E7%89%9B%E7%9A%84%E5%AD%A6%E6%9C%AF%E5%9C%881/</url>
    
    <content type="html"><![CDATA[<h1 id="牛的学术圈-I"><a href="#牛的学术圈-I" class="headerlink" title="牛的学术圈 I"></a>牛的学术圈 I</h1><p>题目来源于[这里](<a href="https://www.acwing.com/problem/content/3748/">3745. 牛的学术圈 I - AcWing题库</a>)</p><p><img src="/images/%E7%89%9B%E7%9A%84%E5%AD%A6%E6%9C%AF%E5%9C%88/QQ%E5%9B%BE%E7%89%8720220316234911.png"></p><p>思路：首先排序，然后确定h的值，由于最多只能让一篇文章+1且数组已经排序，所以从大往小找小于等于h的数让它加一，因为这样才能用最小消耗保证h到h+1，重复这个过程一直到l用完或者所有文章加完，再求一遍h值就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= h + <span class="number">1</span>) h++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; a[i] &lt;= h)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    h = <span class="number">0</span>;</span><br><span class="line">    i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= h + <span class="number">1</span>) h++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string类模拟实现</title>
    <link href="/2022/03/05/string%E7%B1%BB%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/05/string%E7%B1%BB%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="本文是关于cpp中string类的模拟实现"><a href="#本文是关于cpp中string类的模拟实现" class="headerlink" title="本文是关于cpp中string类的模拟实现"></a>本文是关于cpp中string类的模拟实现</h1><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>其中代码结构如下图所示：</p><p><img src="/images/string/string%E7%B1%BB%E7%BB%93%E6%9E%84.png"></p><hr><h2 id="建立工程文件"><a href="#建立工程文件" class="headerlink" title="建立工程文件"></a>建立工程文件</h2><p>首先我们创建出工程文件，并在自己的命名空间内定义好自己的string类(为了防止和std库中的string发生命名污染),如图所示：</p><p><img src="/images/string/string%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B1.png"></p><p><img src="/images/string/string%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B2.png"></p><p>其中文件string.h我们用来实现string类，而文件Test.cpp我们用来对string类的测试。</p><h2 id="设置类中的成员变量"><a href="#设置类中的成员变量" class="headerlink" title="设置类中的成员变量"></a>设置类中的成员变量</h2><p>对于string类中的属性成员，因为我们要实现的是string的增删改查功能，所以必须维护三个成员，这三个成员变量如下图所示：</p><p><img src="/images/string/string%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png"></p><p>其中，_str维护了我们的字符串， _size记录字符串中字符的数量， _capacity记录着这个string空间的大小。</p><h2 id="编写构造函数与析构函数"><a href="#编写构造函数与析构函数" class="headerlink" title="编写构造函数与析构函数"></a>编写构造函数与析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>我们不用编写默认构造和带参数的构造函数两种，我们可以通过带缺省值的构造函数来少写一个不含参数的构造函数：</p><p><img src="/images/string/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png"></p><p>所以缺省值自然是一个空的字符串了</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>释放内存空间并置指针为空：</p><p><img src="/images/string/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.png"></p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>我们不能使用编译器给我们自动提供的拷贝构造，因为自动提供的拷贝构造是浅拷贝，而我们维护的字符串是char*类型，浅拷贝只拷贝了它的地址，之后析构的时候会对这个空间析构两次从而出现错误。</p><p>对于拷贝构造，我们有两种实现方式</p><ul><li>第一种是传入字符串，规规矩矩的开空间，拷贝字符串，拷贝 _size和 _capacity。</li></ul><p><img src="/images/string/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0.png"></p><ul><li>第二种是通过复用构造函数，我们首先先将需要拷贝的类中的 _str设置为空指针，然后调用构造函数，构造出和传入的需要拷贝的string类有着相同字符串的一个类，之后再通过swap函数把 _str和构造出的类中的 _str调换，由于需要拷贝的类中的 _str 一开始被我们设置为nullptr，所以调换完不用理会它，不会产生内存泄漏。</li></ul><p><img src="/images/string/%E7%8E%B0%E4%BB%A3%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0.png"></p><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>有了拷贝构造，我们直接复用它去实现赋值运算符的重载：</p><p><img src="/images/string/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.png"></p><h2 id="返回c语言类型字符串和字符数"><a href="#返回c语言类型字符串和字符数" class="headerlink" title="返回c语言类型字符串和字符数"></a>返回c语言类型字符串和字符数</h2><p>在写完构造函数后，我们想验证构造函数的正确性，可以写一个返回c语言类型的字符串的一个函数，这样我们就能直接打印字符串了，如图所示：</p><p><img src="/images/string/%E8%BF%94%E5%9B%9Ec%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="返回c字符串"></p><p>同样一并实现返回字符个数的函数：</p><p><img src="/images/string/%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0.png" alt="返回字符个数"></p><h2 id="完成遍历字符串操作"><a href="#完成遍历字符串操作" class="headerlink" title="完成遍历字符串操作"></a>完成遍历字符串操作</h2><p>有了返回字符串中字符个数的函数，我们只需要对”[]“操作符进行重载就可以用for循环去打印字符串了。</p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="[]操作符重载"></a>[]操作符重载</h3><p><img src="/images/string/%5B%5D%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD.png"></p><h3 id="迭代器的定义"><a href="#迭代器的定义" class="headerlink" title="迭代器的定义"></a>迭代器的定义</h3><p>对于实现范围for和迭代器循环打印，我们只需要定义一下迭代器就好了，在string中其实就是一个指针：</p><p><img src="/images/string/%E8%BF%AD%E4%BB%A3%E5%99%A8.png"></p><p>在提供一些begin和end函数：</p><p><img src="/images/string/begin%E5%92%8Cend.png"></p><p>这样就能够实现打印循环打印字符了</p><h2 id="字符串增加操作"><a href="#字符串增加操作" class="headerlink" title="字符串增加操作"></a>字符串增加操作</h2><h3 id="实现push-back-函数"><a href="#实现push-back-函数" class="headerlink" title="实现push_back()函数"></a>实现push_back()函数</h3><p>push_back(ch)作用为在字符串最后面追加一个字符ch，为了保证字符串空间够大，我们必须写一个扩容函数reserve()</p><h4 id="实现reserve-函数"><a href="#实现reserve-函数" class="headerlink" title="实现reserve()函数"></a>实现reserve()函数</h4><p>reserve函数的参数是一个非负数n，意思是把string类管理的空间扩容到n字节，逻辑很好实现，首先判断传入的参数是否大于现有空间，如果不大于就直接不处理，大于就开一个新空间，把原来的字符串拷贝到新空间，把新空间的地址给到 _str:<br><img src="/images/string/%E6%89%A9%E5%AE%B9.png" alt="扩容函数"></p><h4 id="实现resize-函数"><a href="#实现resize-函数" class="headerlink" title="实现resize()函数"></a>实现resize()函数</h4><p>既然有了reserve()函数，我们可以实现一下resize()函数。</p><p>resize()函数的作用是将字符串设置为n个字符，并用指定字符填充。</p><p><img src="/images/string/resize.png"></p><p>有了扩容函数，实现push_back()就变得非常简单了:</p><p><img src="/images/string/pushback.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="实现append-函数"><a href="#实现append-函数" class="headerlink" title="实现append()函数"></a>实现append()函数</h3><p>append()函数的作用是在字符串末尾追加字符串，所以实现的逻辑和push_back()类似：首先检查空间是否充足，如果不够就扩容，最后把字符串放进去即可：</p><p><img src="/images/string/append.png"></p><h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="+=操作符重载"></a>+=操作符重载</h3><p>实现了append()函数，对append()函数复用，就可以得到+=操作符重载的实现：</p><p><img src="/images/string/+=%E9%87%8D%E8%BD%BD.png"></p><h3 id="实现insert-函数"><a href="#实现insert-函数" class="headerlink" title="实现insert()函数"></a>实现insert()函数</h3><p>insert函数有两种：</p><ul><li><p>第一种是插入一个字符：<br><img src="/images/string/%E5%AD%97%E7%AC%A6%E6%8F%92%E5%85%A5.png"></p></li><li><p>第二种插入一个字符串：</p><p><img src="/images/string/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%85%A5.png"></p></li></ul><h2 id="字符串逻辑运算符"><a href="#字符串逻辑运算符" class="headerlink" title="字符串逻辑运算符"></a>字符串逻辑运算符</h2><p>对于逻辑运算符，我们只需要实现小于和等于，其他的都可以通过复用实现，比如要实现大于，其实就是不小于等于。</p><h3 id="lt-运算符实现"><a href="#lt-运算符实现" class="headerlink" title="&lt;运算符实现"></a>&lt;运算符实现</h3><p><img src="/images/string/string%E5%B0%8F%E4%BA%8E.png" alt="string小于"></p><h3 id="运算符实现"><a href="#运算符实现" class="headerlink" title="==运算符实现"></a>==运算符实现</h3><p><img src="/images/string/string%E7%AD%89%E4%BA%8E.png" alt="string等于"></p><h3 id="其余各种逻辑运算符"><a href="#其余各种逻辑运算符" class="headerlink" title="其余各种逻辑运算符"></a>其余各种逻辑运算符</h3><p><img src="/images/string/string%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><p>find()函数的实现比较简单，这里不再赘述：</p><p><img src="/images/string/find.png"></p><p>对于这里的查找字串函数，可以使用更高效的算法比如kmp，这里笔者偷个懒直接使用时间复杂度较高的strstr()库函数</p><h2 id="实现clear-和erase-以及流插入运算符"><a href="#实现clear-和erase-以及流插入运算符" class="headerlink" title="实现clear()和erase()以及流插入运算符"></a>实现clear()和erase()以及流插入运算符</h2><h4 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a>clear()函数</h4><p>clear函数的实现比较简单，直接在下标为0处放入’\0’，再把 _size改成0即可:</p><p><img src="/images/string/stringclear.png"></p><h4 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h4><p>erase()函数第一个参数是一个非负整数，表示从这个位置开始删除，第二个参数也是一个非负整数，表示要删除的字符数：</p><p><img src="/images/string/stringerase.png"></p><h4 id="流插入运算符重载"><a href="#流插入运算符重载" class="headerlink" title="流插入运算符重载"></a>流插入运算符重载</h4><p>这个比较简单，跟着模板来，遍历输出字符串就好：</p><p><img src="/images/string/string%E6%B5%81%E6%8F%92%E5%85%A5.png"></p><p>至此，string常用的函数我们都已经实现，本篇文章到此结束，谢谢观看！</p><p><em><strong>the end</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原博客地址</title>
    <link href="/2022/03/02/%E5%8E%9F%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/03/02/%E5%8E%9F%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="关于原博客地址"><a href="#关于原博客地址" class="headerlink" title="关于原博客地址"></a>关于原博客地址</h1><p>关于本人的原博客地址请<a href="https://blog.csdn.net/qq_55783740?spm=1011.2124.3001.5343">点击这里</a></p>]]></content>
    
    
    <categories>
      
      <category>说明</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
