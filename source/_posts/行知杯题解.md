---
title: 新年赛题解
date: 2022-03-19 14:02:19
tags: 算法
---

# A题

![](/images/知行杯/A.png)

思路：由于每个数字只会出现一次，我们可以先排序，之后每个数字的下标和值会相等，例如a[0] = 0,a[1] = 1，我们只需要遍历数组，找到第一个数组下标和值不等的地方，这个就是缺少的数字。

```cpp
#include <iostream>
using namespace std;
#include <algorithm>

const int N = 1e6 + 10;
int a[N];
int n;

int main()
{
	cin >> n;
	for(int i = 0;i < n;i++) scanf("%d", a + i);
	
	sort(a, a + n);   //排序
	
    //找第一个数组下标和数字不同的地方
	for(int i = 0;i < n;i++)
	{
		if(a[i] != i) 
		{
			cout << i << endl;
			break;
		}
	}
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# B题

![](/images/知行杯/B.png)

思路：由于只用64个位置，我们可以遍历64个格子并且维护一个变量ans = 0，每个格子假设是我们放马的格子，每次判断我们放的马的八个方向和本来已经在棋盘上的方向，如果合法ans++，最后输出的ans就是合法格子数

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 10;
int g[N][N];
int dx[] = {-1,-2,-2,-1,1,2,2,1}, dy[] = {-2,-1,1,2,2,1,-1,-2};   //马的八个方向分量

int main()
{
	char op[3];
	scanf("%s", op);  //读入坐标
	int a = op[0] - 'a' + 1, b = op[1] - '0';   //将字符坐标转换成整形
	scanf("%s", op);
	int c = op[0] - 'a' + 1, d = op[1] - '0';
	
	int ans = 0;   
	for(int i = 1;i <= 8;i++)
	{
		for(int j = 1;j <= 8;j++)
		{
			if(i == c && j == d) continue;     //如果这个位置是马在的位置直接跳过
			if(i == a || j == b) continue;     //如果这个位置是车的所在的行或者列直接跳过
			bool flag = true;
			//遍历棋盘上原来的马的八个方位
			for(int k = 0;k < 8;k++)
			{
				int tx = c + dx[k];
				int ty = d + dy[k];
				if(tx < 1 || tx > 8 || ty < 1 || ty > 8) continue;   //如果坐标越界直接跳过
				if(tx == i && ty == j) flag = false;                 //如果棋盘上的马能踩到(i,j)的马，这个位置不能放
			}
			if(!flag) continue;  
			//遍历我们要放的马的八个方向
			for(int k = 0;k < 8;k++)
			{
				int tx = i + dx[k];
				int ty = j + dy[k];
				if(tx < 1 || tx > 8 || ty < 1 || ty > 8) continue;     //如果坐标越界直接跳过
				if((a == tx && b == ty))
				{
					flag = false;                 //如果这个方向能攻击到棋盘上原有的马，坐标不合法
					break;
				}
			}
			if(!flag) continue;
			ans++;
		}
	}
	
	cout << ans << endl;
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# C题

![](/images/知行杯/C.png)

思路：维护两个变量：字符A的数量asize和字符A的数量bsize

- 如果当前字符是A，asize++
- 如果当前字符是B，bsize++

```cpp
#include <iostream>
using namespace std;

int main()
{
	int n;
	cin >> n;
	int a = 0,b = 0;    //字符a的数量和字符b的数量
	for(int i = 0;i < n;i++)
	{
		char ch;
		scanf(" %c", &ch);
		if(ch == 'A') a++;
		else b++;
	}
	
	if(a == b) cout << 'T' << endl;   
	else if(a > b) cout << 'A' << endl;
	else cout << 'B' << endl;
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# D题

![](/images/知行杯/D.png)

思路：数据量是1000，如果三重循环，我们要计算1e9级别的数据，这样肯定是会超时的，我们先排序，由于第三重循环要在[XY,2XY]中，且排序后数据单调，我们可以使用二分查找找到第一个大于等于XY的数的下标和最后一个小于2XY的数的下标，得到了下标之后，下标相减加1就是当前的合法三元组数量

时间复杂度分析，排序nlogn + 二重循环和两次二分2 * N^2logn为O(N^2 log n)，符合题目要求

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

vector<int> alls;
int n;

int check(int l1,int r1,int t1,int t2)
{
	int l = l1,r = r1;
	while(l < r)
	{
		int mid = l + ((r - l) >> 1);
		if(alls[mid] >= t1) r = mid;
		else l = mid + 1;
	}
	
	int ans1 = l;
	l = l1,r = r1;
	while(l < r)
	{
		int mid = l + r + 1 >> 1;
		if(alls[mid] <= t2) l = mid;
		else r = mid - 1;
	}
	int ans2 = l;
	if(ans2 == ans1)
	{
		if(alls[ans1] >= t1 && alls[ans1] <= t2) return 1;
	}
	else if(ans2 > ans1) return ans2 - ans1 + 1;
	return 0;
}

int main()
{
	cin >> n;
	//读入数据
	for(int i = 0;i < n;i++)
	{
		int x;
		cin >> x;
		alls.push_back(x);
	}
	
	//排序
	sort(alls.begin(), alls.end());
	
	int ans = 0;
	for(int i = 0;i < alls.size();i++)
	{
		for(int j = i + 1;j < alls.size();j++)
		{
			int temp = check(j + 1,alls.size() - 1,alls[j] - alls[i] + alls[j], 2 * (alls[j] - alls[i]) + alls[j]); //二分查找
			if(temp) ans += temp;
		}
	}
	
	cout << ans << endl;
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# E题

![](/images/知行杯/E.png)

思路：通过dfs把两块区域的点记录下来，之后二重循环遍历所有两块区域中的点，算他们的曼哈顿距离-1，并得到最小的距离，时间复杂度度O(m*n)，具体看代码实现

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 55;
int n,m;
char map[N][N];
bool v[N][N];
typedef pair<int, int> PII;
vector<PII> a,b;   //a存放第一块区域的坐标，b存放第二块区域的坐标
int temp;    //如果当前的temp == 0，代表都是第一块区域的坐标，把坐标往a存，如果temp == 1，把坐标往b存

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};    //上下左右四个坐标分量


void dfs(int x,int y)
{
	v[x][y] = 1;   //标记当前点已经被访问过
	if(map[x][y] == 'X')
	{
		map[x][y] = '.';
		
		//如果当前的temp == 0，代表都是第一块区域的坐标，把坐标往a存，如果temp == 1，把坐标往b存
		if(temp == 0)
		{
			a.push_back({x,y});
		}
		else
		{
			b.push_back({x,y});
		}
		for(int i = 0;i < 4;i ++)
		{
			int x1 = x + dx[i];
			int y1 = y + dy[i];
			if(x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && !v[x1][y1])
			{
				dfs(x1,y1);
			}
		}
	}
}

int main()
{
	cin >> n >> m;
	for(int i = 0;i < n;i ++) scanf("%s", map[i]);
	
	for(int i = 0;i < n;i++)
	{
		for(int j = 0;j < m;j++) 
		{
			if(map[i][j] == 'X')   //如果是'X'则是我们要dfs的地方
			{
				dfs(i,j);
				temp++;
			}
		}
	}
	int ans = 1000;   //ans任取一个大值
	for(auto i : a)
	{
		for(auto j : b)
		{
			ans = min(ans,abs(i.first - j.first) + abs(i.second - j.second) - 1);   //求出最小的两个坐标之间的距离
		}
	}
	cout << ans << endl;
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# F题

![](/images/知行杯/F.png)

思路：此题为线性dp，我们需要考虑状态转移方程

- 定义f[i]表示从0号车到i - 1号车之间，我们能偷到的最大金额为f[i]，所以答案为f[n - 1]
- 分类讨论f[i]
  1. 如果我们不偷i号车，那么f[i] = f[i - 1]
  2. 如果我们偷i号车，那么f[i] = f[i - 2] + v[i]    (因为相邻的车偷不了，所以是f[i - 2]，v[i]表示下标为i号车的价值)
- 由于我们要最大价值，所以f[i] = max(f[i - 1], f[i - 2] + v[i])
- 分析初始状态，如果只有一辆车，能偷到的最大金额就是这辆车的价值(一定偷)，所以f[0] = v[0]，如果只有两辆车，能偷到的最大金额就是两辆车中价值大的那一辆，所以f[1] = max(v[0], v[1])

```cpp
#include <iostream>
using namespace std;

const int N = 1010;
int f[N];    //f[i]表示从0好车到i - 1号车之间，我们能偷到的最大金额为f[i]，所以答案为f[n - 1]
int a[N];    //a[i]表示下标为i号的车价值为a[i]

int main()
{
	int n;
	cin >> n;
	
	for(int i = 0;i < n;i++) cin >> a[i];
	
	if(n == 1) cout << a[0] << endl;
	else 
	{
		f[0] = a[0];
		f[1] = max(a[0], a[1]);
		for(int i = 2;i < n;i++) f[i] = max(f[i - 1], f[i - 2] + a[i]);
		
		cout << f[n - 1] << endl;
	}
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# G题

![](/images/知行杯/G.png)

```c++
#include <stdio.h>

int main()
{
	printf("95\n");
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# H题

![](/images/知行杯/H.png)

![](/images/知行杯/无标题.png)

如图所示：有三种情况，定义f[i]表示长为i米的放陷阱方法为f[i]种

不难得出f[i] = f[i - 1] + f[i - 2] + f[i - 2]

```cpp
#include <iostream>
using namespace std;

const int N = 31;
int f[N];

int main()
{
	f[1] = 1;    //一米长的就1种
	f[2] = 3;    //二米长的就3种
	for(int i = 3;i <= 30;i++) f[i] = f[i - 1] + 2 * f[i - 2];
	
	int tt;
	cin >> tt;
	while(tt--)
	{
		int x;
		cin >> x;
		cout << f[x] << endl;
	}
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# I题

![](/images/知行杯/I.png)

![](/images/知行杯/I题解.png)

思路：如图所示:

- a和c点取小的，b和d点取大的，然后相减得到一条边的长度

- e和g点取大的，f和h点取小的，然后相减得到另一条边的长度

由于要正方形，所以两条边的长度取长的平方得到的面积就是答案

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

int main()
{
	int x1,y1,x2,y2,x3,y3,x4,y4;
	cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;
	
	int a = min(x1,x3),b = min(y1,y3);
	int c = max(x2,x4),d = max(y2,y4);
	
	int ans = max(abs(a - c), abs(b - d));
	
	cout << ans * ans << endl;
	
	return 0;
}

//作者：晓伍
//链接：http://124.223.78.3/
//著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

