---
title: 基于阻塞队列的生产消费者模型实现
date: 2023-01-03 19:03:53
tags: linux
categories: linux
---

# 1.模型介绍

生产者消费者模型就是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者

要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。

# 2.模型优点

- 解耦
- 支持并发
- 支持忙闲不均

# 3.基于BlockingQueue的生产消费者模型

在多线程编程中`阻塞队列(Blocking Queue)`是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)

![](/images/基于阻塞队列的生产消费者模型实现/1.png)

# 4.代码实现

## 4.1Blocking Queue.hpp主体代码

```cpp
#pragma once
#include <iostream>
#include <queue>
#include <pthread.h>

namespace ns_block_queue
{
    const int g_cap = 5;
    template <class T>
    class BlockQueue
    {
    private:
        std::queue<T> bq_;
        int cap_;
        pthread_mutex_t mtx_;
        pthread_cond_t full_;  // full表示是否有产品，消费者等
        pthread_cond_t empty_; // empty表示是否有空位，生产者等
    private:
        void Lock()
        {
            pthread_mutex_lock(&mtx_);
        }

        void UnLock()
        {
            pthread_mutex_unlock(&mtx_);
        }

        void WaitEmpty()
        {
            // 等空位
            pthread_cond_wait(&empty_, &mtx_); // 第二个参数是挂起时交出的锁
        }

        void WaitFull()
        {
            // 等产品
            pthread_cond_wait(&full_, &mtx_);
        }

        void SignalConsumer()
        {
            // 通知消费者有产品
            pthread_cond_signal(&full_);
        }

        void SignalProducter()
        {
            // 通知生产者已经有空位了
            pthread_cond_signal(&empty_);
        }

        bool IsFull()
        {
            return cap_ == bq_.size();
        }

        bool IsEmpty() 
        {
            return bq_.empty();
        }

    public:
        BlockQueue(int cap = g_cap) : cap_(cap)
        {
            pthread_mutex_init(&mtx_, nullptr);
            pthread_cond_init(&full_, nullptr);
            pthread_cond_init(&empty_, nullptr);
        }
        ~BlockQueue()
        {
            pthread_mutex_destroy(&mtx_);
            pthread_cond_destroy(&full_);
            pthread_cond_destroy(&empty_);
        }

    public:
        void Push(const T &in)
        {
            Lock();
            while (IsFull())
            {
                WaitEmpty();
            }
            bq_.push(in);
            UnLock();
            SignalConsumer();   //通知消费者
        }

        void Pop(T *out)
        {
            Lock();
            while(IsEmpty())
            {
                WaitFull();
            }
            *out = bq_.front();
            bq_.pop();
            UnLock();
            SignalProducter();  //通知生产者
        }
    };
}
```

## 4.2模拟任务派发的Task.hpp任务类代码

```cpp
#pragma once
#include <iostream>

namespace ns_task {
    class Task {
    private:
        int x_;
        int y_;
        char op_;
    public:
        Task() {};
        Task(int x, int y, char op):x_(x), y_(y), op_(op){};
        ~Task(){};

        int Run() {
            int ans = 0;
            switch (op_)
            {
            case '+':
                ans = x_ + y_;
                break;
            case '-':
                ans = x_ - y_;
                break;
            case '*':
                ans = x_ * y_;
                break;
            case '/':
                ans = x_ / y_;
                break;
            case '%':
                ans = x_ % y_;
                break;
            
            default:
                std::cout << "Bug????" << std::endl;
                break;
            }            
            std::cout << "当前任务正在被" << pthread_self() << "线程处理：" << x_ << op_ << y_ << "=" << ans << std::endl;
            return ans;
        }

        int operator()() {
            return Run();
        }
    };
}

```

## 4.3模拟生产消费者运行代码

```cpp
#include "BlockQueue.hpp"
#include "Task.hpp"
#include <cstdlib>
#include <ctime>
#include <unistd.h>

using namespace ns_block_queue;
using namespace ns_task;

void *consumer(void *arg)
{
    BlockQueue<Task> *bq = (BlockQueue<Task> *)arg;
    while (1)
    {
        // 消费
        Task t;
        bq->Pop(&t);
        t();
    }
}

void *producter(void *arg)
{
    BlockQueue<Task> *bq = (BlockQueue<Task> *)arg;
    std::string ops = "+-*/%";
    while (1)
    {
        // 生产
        int x = rand() % 20 + 1;
        int y = rand() % 20 + 1;
        char op = ops[rand() % 5];
        Task t(x, y, op);
        bq->Push(t);
        std::cout << "生产者" << pthread_self() << "生产了" << x << op << y << std::endl;
        sleep(1);
    }
}

int main()
{
    srand((unsigned int)time(nullptr));
    BlockQueue<Task> *bq = new BlockQueue<Task>();

    pthread_t c[3], p[5];
    for (int i = 0; i < 5; i++)
    {
        pthread_create(p + i, nullptr, producter, (void *)bq);
    }
    for (int i = 0; i < 3; i++)
    {
        pthread_create(c + i, nullptr, consumer, (void *)bq);
    }

    for (int i = 0; i < 5; i++)
    {
        pthread_join(p[i], nullptr);
    }

    for (int i = 0; i < 3; i++)
    {
        pthread_join(c[i], nullptr);
    }

    return 0;
}
```

## 4.4makefile

```makefile
CpTest:CpTest.cc
	g++ -o $@ $^ -std=c++11 -lpthread

.PHONY:clean
clean:
	rm -f CpTest
```

# 5运行效果

![](/images/基于阻塞队列的生产消费者模型实现/2.png)
